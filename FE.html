1️⃣ Cơ số là gì?

Cơ số (基数): số lượng ký tự dùng để biểu diễn số.

Trong FE hay ra 4 loại:

Cơ số  	Tên  	Ký hiệu	  Ví dụ
2	  Nhị phân	(2進数)	  1011
8  	Bát phân	(8進数)  	17
10	Thập phân	(10進数)  	11
16	Thập lục phân	(16進数)	B, 1F

👉 16 tiến có thêm chữ:
A=10, B=11, C=12, D=13, E=14, F=15


2️⃣ Nhị phân → Thập phân (2 → 10)
Cách làm

👉 Nhân từng bit với 2ⁿ rồi cộng lại

Ví dụ:

1011(2)
= 1×2³ + 0×2² + 1×2¹ + 1×2⁰
= 8 + 0 + 2 + 1
= 11(10)
📌 Thi FE rất hay ra dạng này


3️⃣ Thập phân → Nhị phân (10 → 2)
ÁP DỤNG ➡ Dạng: 8 – 4 – 2 – 1
✅ CÁCH 1 (TỐT NHẤT – KHÔNG CẦN THUỘC)

👉 Viết số hex thành tổng 8-4-2-1

Ví dụ: 9
9 = 8 + 1

8	4	2	1
1	0	0	1

➡ 1001

NẾU SỐ THẬP PHÂN LỚN CÓ THỂ DÙNG CÁCH 2: TỪ THẬP PHÂN → HEX → NHỊ PHÂN (siêu nhanh)
👉 FE ra rất nhiều câu có HEX

Bước:

  1️⃣ Đổi 10 → 16 (chia cho 16, rất ít bước)
  2️⃣ Mỗi 1 hex = 4 bit

Ví dụ: 156(10)
156 ÷ 16 = 9 dư 12 → C
9 ÷ 16 = 0 dư 9
→ 9C(16)
 N
Hex → nhị phân:
9  → 1001
C  → 1100 

➡ 10011100(2)

⏱ Cực nhanh – cực chuẩn FE

✅ĐỐI VỚI SỐ THẬP PHÂN 
VÍ DỤ 107.25(10) SANG NHỊ PHÂN
  Bước 1: 👉 Nhân phần thập phân với 2
  Ví dụ: 0.25
  0.25 × 2 = 0.5  → 0
  0.5 × 2 = 1.0   → 1 (dừng)
  ➡ đọc theo thứ tự: 0.01(2)

📦 Áp dụng cho 117.25
Phần nguyên
117 = 64 + 32 + 16 + 4 + 1
→ 1110101(2)

Phần thập phân
0.25 = 0.01(2)
KẾT QUẢ:
➡ 117.25(10) = 1110101.01(2)



4️⃣ Nhị phân ↔ Bát phân (2 ↔ 8)

👉 3 bit = 1 chữ số bát phân
Nhị phân	Bát phân
  000      	0
  001	      1
  010	      2
  011	      3
  100	      4
  101	      5
  110	      6
  111	      7

Ví dụ:
  
  101011(2)
  → 101 | 011
  → 5   | 3
  → 53(8)


📌 Không cần tính toán – chỉ nhóm bit

5️⃣ Nhị phân ↔ Thập lục phân (2 ↔ 16)

👉 4 bit = 1 chữ số hex

Nhị phân	Hex
    0000	0
    1001	9
    1010	A
    1011	B
    1100	C
    1111	F

Ví dụ:
  
  10111100(2)
  → 1011 | 1100
  → B    | C
  → BC(16)


6️⃣ Thập lục phân → Thập phân (16 → 10)

👉 Nhân với 16ⁿ

Ví dụ:

  1F(16)
  = 1×16¹ + F×16⁰
  = 16 + 15
  = 31(10)



   TƯ DUY QUAN TRỌNG ĐỂ KHÔNG BỊ RỐI
Trường hợp	Cách dùng
HEX → 2	8421
2 → HEX	nhóm 4 bit
10 → 2 (số lớn)	bảng 2ⁿ
10 → 2 (thi FE)	đi vòng qua HEX



7️⃣ Cơ số 8,16 → Nhị phân (8/16 sang nhị phân)
🔑 NGUYÊN TẮC VÀNG (chỉ cần nhớ 2 dòng)

  Cơ số 8 → nhị phân: 1 chữ = 3 bit
  Cơ số 16 → nhị phân: 1 chữ = 4 bit

  📌Ví dụ:
    8 = 2³
    16 = 2⁴

 CƠ SỐ 8 → NHỊ PHÂN (3 bit)
  Bảng cần nhớ (rất ngắn)
  Bát phân	Nhị phân
    0     	000
    1	      001
    2	      010
    3	      011
    4	      100
    5	      101
    6	      110
    7	      111

  Ví dụ
  6(8) → 110(2)


  157(8)
  → 1   | 5   | 7
  → 001 | 101 | 111
  → 001101111(2)

* SO SÁNH NHANH (để không nhầm)
Cơ số	      Số bit / chữ	      Cách làm
8	           3 bit	           tra bảng
16	        4 bit	               8421  

  CƠ SỐ 16 → NHỊ PHÂN (4 bit)
    Bảng cần nhớ (rất ngắn)
    Hex	Nhị phân
      0     	0000
      1	      0001
      2	      0010
      3	      0011
      4	      0100
      5	      0101
      6	      0110
      7	      0111
      8	      1000
      9	      1001
      A	      1010
      B	      1011
      C	      1100
      D	      1101
      E	      1110
      F	      1111
  
    Ví dụ
    B(16) → 1011(2)


🎯 CÂU CHỐT ĐỂ NHỚ
8 = 2³ → 3 bit
16 = 2⁴ → 4 bit
Không chia – không tính – chỉ nhóm



🔢 Hệ nhị phân số âm là gì?

👉 Số âm trong nhị phân KHÔNG viết dấu “−” như thập phân.
👉 Máy tính dùng mã bù 2 (Two’s Complement / 2の補数) để biểu diễn số âm.

📌 FE Nhật hỏi gần như 100% là mã bù 2.

  0 → số dương

  1 → số âm

3️⃣ Cách tạo số âm (quan trọng nhất)

Giả sử dùng 8 bit (hay ra thi FE).

Ví dụ: tạo -5
Bước 1️⃣: Viết +5 ở nhị phân
5 = 00000101

Bước 2️⃣: Đảo bit (bù 1)
00000101 → 11111010

Bước 3️⃣: +1 (bù 2)
11111010 + 1 = 11111011


➡ −5 = 11111011 (8 bit)


===============================================================

 CỘNG – TRỪ – NHÂN – CHIA trong nhị phân
🔢 1️⃣ CỘNG NHỊ PHÂN (dễ nhất)
Quy tắc (chỉ 4 dòng)
Phép	Kết quả
0 + 0	0
0 + 1	1
1 + 0	1
1 + 1	10 (viết 0, nhớ 1)
10 + 1	11 (viết 1, nhớ 1)
11 + 1	100 (viết 0, nhớ 1)

  Ví dụ
    1011
  + 0110
  ------
   10001

  🔢 2️⃣ TRỪ NHỊ PHÂN (CÁCH DỄ NHẤT)

👉 KHÔNG trừ trực tiếp, mà:

Trừ = cộng với số âm (bù 2)
Ví dụ: 7 − 3
7 = 0111
3 = 0011

Tạo −3:

0011 → đảo bit → 1100
1100 + 1 = 1101

Cộng:

 0111
+1101
------
100100  (bỏ bit thừa)


➡ 0100 = 4

📌 Cách này dễ hơn mượn bit

🔢 3️⃣ NHÂN NHỊ PHÂN (giống hệt thập phân)

👉 Nhân từng bit rồi dịch trái
2️⃣ Dạng câu FE thích ra nhất
🔹 Dạng 1: Nhận biết dịch bit

    00100000 >> 3 = ?
  → 32 ÷ 8 = 4
🔹 Dạng 2: Hỏi quan hệ

Dịch trái 1 bit tương đương phép toán nào?

✅ Nhân 2



Nhân	Kết quả
×0	0
×1	giữ nguyên

Ví dụ: 5 × 3
        101
      × 011
      -----
        101
      1010
      -----
      1111
  
➡ 15(10)

📌 Nhân 1 → giữ
📌 Nhân 0 → bỏ
📌 Dịch trái khi xuống dòng

🔢 4️⃣ CHIA NHỊ PHÂN (dễ nhất kiểu FE)

👉 Chia cho 2ⁿ = dịch phải

Ví dụ
1000 ÷ 10 = 100   (÷2)
1000 ÷ 100 = 10   (÷4)


📌 Khi thi FE:

Thường chỉ hỏi chia cho 2, 4, 8

⚠️ Nếu chia không phải 2ⁿ

👉 FE thường đổi về thập phân hoặc hex rồi so

🧠 MẸO NHỚ SIÊU NGẮN

➕ Cộng → nhớ khi 1+1

➖ Trừ → đổi sang cộng bù 2

✖ Nhân → nhân 0/1 + dịch trái

➗ Chia → dịch phải (nếu chia 2ⁿ)

🎯 CÂU CHỐT PHẢI NHỚ

Nhị phân dễ vì chỉ có 0 và 1
Trừ = cộng bù 2
Nhân / chia = dịch bit

===============================================================

Cấu trúc dữ liệu cơ bản

🔥 1. Mảng (Array – 配列) [CỰC KỲ QUAN TRỌNG]

📌 Ra nhiều nhất

Hay hỏi:

Truy cập phần tử theo index

Mảng 1 chiều, 2 chiều

Mô phỏng for / while

Thêm – xóa phần tử (phải dịch phần tử)

Ví dụ:
A = [3, 5, 7, 9]
A[2] = ?


➡️ Đáp án: 7

👉 Mẹo thi FE

Index thường bắt đầu từ 0

Cẩn thận vòng lặp chạy tới < n hay <= n-1

🔥 2. Ngăn xếp – Stack (スタック)

📌 Rất hay ra

Đặc điểm:

LIFO (Last In – First Out)

Push / Pop

Dạng câu hỏi:

Mô phỏng các bước push/pop

Tính phần tử trên cùng (top)

Ví dụ:
Push 1 → Push 2 → Pop → Push 3


➡️ Stack cuối: [1, 3]
➡️ Top = 3

👉 Nhớ kỹ:

Pop → lấy ra phần tử mới nhất

🔥 3. Hàng đợi – Queue (キュー)

📌 Ra ít hơn stack nhưng vẫn rất đều

Đặc điểm:

FIFO (First In – First Out)

Enqueue / Dequeue

Dạng hay gặp:

Mô phỏng thứ tự ra khỏi hàng

So sánh Queue vs Stack

Ví dụ:
Enqueue A → Enqueue B → Dequeue → Enqueue C


➡️ Queue cuối: [B, C]

🔥 4. Danh sách liên kết – Linked List (連結リスト)

📌 Hay ra ở mức lý thuyết + mô phỏng nhẹ

Hỏi về:

Node (data + pointer)

Thêm / xóa node

Khác gì với mảng

So sánh hay ra:
Mảng	Linked List
Truy cập nhanh	Truy cập chậm
Khó chèn/xóa	Chèn/xóa dễ
Cần bộ nhớ liên tục	Không cần
🔥 5. Cây nhị phân – Binary Tree (2分木)

📌 Ra khá nhiều, nhất là phần duyệt cây

Hay hỏi:

Preorder / Inorder / Postorder

Cấu trúc cây

Nhớ thứ tự:

Preorder: Root – Left – Right

Inorder: Left – Root – Right

Postorder: Left – Right – Root

👉 Inorder của BST → ra dãy tăng dần

🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥
Thuật toán sắp xếp
🔥 1. Bubble Sort (バブルソート) Sắp xếp nổi bọt
📌 Rất hay ra FE
Ý tưởng:
So sánh từng cặp phần tử kề nhau
Nếu sai thứ tự thì đổi chỗ
Ví dụ:
A = [5, 3, 8, 4]
Pass 1: [3, 5, 4, 8]
Pass 2: [3, 4, 5, 8]
➡️ Kết quả: [3, 4, 5, 8]

🔥 2. Selection Sort (選択ソート) Sắp xếp chọn

📌 Rất hay ra FE
Ý tưởng:
Tìm phần tử nhỏ nhất trong mảng. TÌM Min trong mảng
Đổi chỗ với phần tử đầu tiên
Lặp lại cho các phần tử còn lại
Ví dụ:
A = [5, 3, 8, 4] Min trong mảng là 3, đổi với 5
Pass 1: [3, 5, 8, 4] Min trong mảng còn lại là 4, đổi với 5
Pass 2: [3, 4, 8, 5] Min trong mảng còn lại là 5, đổi với 8
Pass 3: [3, 4, 5, 8] 
➡️ Kết quả: [3, 4, 5, 8] 

🔥 3. Insertion Sort (挿入ソート) Sắp xếp chèn

📌 Rất hay ra FE
Ý tưởng:
Chèn từng phần tử vào vị trí đúng trong mảng đã sắp xếp, hoặc gần sắp xếp
Ví dụ:
A = [5, 3, 8, 4] So sánh: 3 < 5 → dịch 5 sang phải
Pass 1: [3, 5, 8, 4]  So sánh: 8 > 5 → giữ nguyên
Pass 2: [3, 5, 8, 4]  So sánh: 4 < 8 → dịch 8 sang phải; 4 < 5 → dịch 5 sang phải
Pass 3: [3, 4, 5, 8]  
➡️ Kết quả: [3, 4, 5, 8]

🔥 4. Quick Sort (クイックソート) Sắp xếp nhanh

📌 Rất hay ra FE
Ý tưởng:
Chọn phần tử pivot
Phân chia mảng thành hai phần: nhỏ hơn pivot và lớn hơn pivot
Đệ quy sắp xếp hai phần
Ví dụ:
A = [5, 3, 8, 4]
Chọn pivot = 5
Phân chia: [3, 4] và [8]
Sắp xếp đệ quy: [3, 4] và [8]
➡️ Kết quả: [3, 4, 5, 8]

🔥 5. Merge Sort (マージソート) Sắp xếp trộn

📌 Rất hay ra FE
Ý tưởng:
Chia mảng thành hai phần bằng nhau
Đệ quy sắp xếp hai phần
Trộn hai phần đã sắp xếp lại
Ví dụ:
A = [5, 3, 8, 4]
Chia: [5, 3] và [8, 4]
Sắp xếp: [3, 5] và [4, 8]
Trộn: [3, 4, 5, 8]
➡️ Kết quả: [3, 4, 5, 8]

######################################################
TÌM KIẾM

 🔥Tìm kiếm tuyến tính 
📌 Rất hay ra FE
Ý tưởng:
Duyệt từng phần tử trong mảng
Ví dụ:
A = [5, 3, 8, 4], tìm 4
➡️ Kết quả: A[3]

🔥Tìm kiếm nhị phân
📌 Rất hay ra FE
Ý tưởng:
So sánh phần tử cần tìm với phần tử giữa mảng
Nếu bằng → tìm thấy
Nếu nhỏ hơn → tìm trong nửa trái
Nếu lớn hơn → tìm trong nửa phải
Ví dụ:
A = [3, 4, 5, 8], tìm 5
➡️ Kết quả: A[2]

🔥Tìm kiếm ánh xạ (Hash code) 
📌 Ít ra FE hơn nhưng vẫn quan trọng
Ý tưởng:
Dùng hàm băm để tính vị trí của phần tử trong bảng băm
Ví dụ:
A = [3, 4, 5, 6, 9, 8], tìm 5
Hash(5) = 2
➡️ Kết quả: A[2]

Tăng tốc độ tìm kiếm bằng giá trị hash nhưng có thể xảy ra xung đột dữ liệu

🔥Thuật toán hồi quy  
📌 Rất hay ra FE
Ý tưởng:
Gọi lại chính hàm đó với các tham số khác
Ví dụ:
Công thức
f(x) =
1 ( khi x <= 1)
x + f(x - 1) ( khi x > 1)
f(5) = 5 + f(4)
= 5 + 4 + f(3)
= 5 + 4 + 3 + f(2)
= 5 + 4 + 3 + 2 + f(1)
= 5 + 4 + 3 + 2 + 1 = 15
➡️ Kết quả: 15
 
######################################################
(n) : Độ phức tạp
(計算量)
Độ phức tạp của các thuật toán
O(n) , O(n²),...có nghĩa là gì ?  
Khi lượng dữ liệu tăng 2 lần thì lượng tính toán cũng tăng 2 lần, 3 lần thì lượng tính toán cũng tăng 3 lần
Ví dụ:
Thuật toán A: O(n)
Khi dữ liệu là 10 thì tính toán là 10
Khi dữ liệu là 100 thì tính toán là 100
Thuật toán B: O(n²)
Khi dữ liệu là 10 thì tính toán là 100
Khi dữ liệu là 100 thì tính toán là 10,000

🔥 Độ phức tạp của các thuật toán sắp xếp phổ biến
Thuật toán	        Độ phức tạp
Bubble Sort	    O(n²) ➡️ バブルソート
Selection Sort	O(n²) ➡️ 選択ソート
Insertion Sort	O(n²) ➡️ 挿入ソート
Quick Sort	    O(n log n) ➡️ クイックソート
Merge Sort	    O(n log n) ➡️ マージソート

🔥 Độ phức tạp của các thuật toán tìm kiếm phổ biến
Thuật toán	        Độ phức tạp
Tìm kiếm tuyến tính	O(n) ➡️ 線形探索
Tìm kiếm nhị phân	O(log n) ➡️ 二分探索
Tìm kiếm ánh xạ (Hash)	O(1) trung bình, O(n) tệ nhất ➡️ ハッシュ探索


🔥 Độ phức tạp của các cấu trúc dữ liệu phổ biến
Cấu trúc dữ liệu	Thời gian truy cập	Thời gian chèn/xóa
Mảng (Array)	        O(1)	            O(n)
Danh sách liên kết (Linked List)	O(n)	            O(1)
Ngăn xếp (Stack)	    O(1)	            O(1)
Hàng đợi (Queue)	    O(1)	            O(1)
Cây nhị phân tìm kiếm (🌳 木構造 )  	O(log n)	      O(log n)


Đệ Quy 再帰・分割統治（Recursion / Divide & Conquer）
再帰フィボナッチ
👉 O(2ⁿ)

動的計画法（DP）フィボナッチ
👉 O(n)

🔥 Cách đọc độ phức tạp
O(1) : Hằng số
O(log n) : Lô-ga-rít
O(n) : Tuyến tính
O(n log n) : Tuyến tính lô-ga-rít
O(n²) : Bình phương
🔥 MẸO NHỚ ĐỘ PHỨC TẠP
➕ Độ phức tạp càng thấp càng tốt
➖ O(1) < O(log n) < O(n) < O(n log n) < O(n²)
➗ Thuật toán chia để trị thường có độ phức tạp O(n log n)
===============================================================
################################################################ 

🔥🔥🔥🔥QUY TRÌNH XỬ LÝ CỦA CPU🔥🔥🔥🔥🔥🔥🔥🔥

🔥 CPUの処理手順（FE頻出）
🧠 Quy trình cơ bản của CPU
👉 フェッチ → デコード → 実行
1️⃣ フェッチ（Fetch）– Lấy lệnh

メモリから命令を取り出す

PC（プログラムカウンタ）使用

PCは次の命令を指す

👉 PC = địa chỉ lệnh tiếp theo

2️⃣ デコード（Decode）– Giải mã lệnh

命令を解析する

何をする命令か判断

必要なレジスタ・ALUを決定

👉 Chỉ phân tích, chưa xử lý

3️⃣ 実行（Execute）– Thực thi

ALUで計算

メモリアクセス

レジスタに結果保存

PC更新

👉 Tạo ra kết quả

🔁 Lệnh truy cập bộ nhớ (rất hay ra)

LOAD：メモリ → レジスタ

STORE：レジスタ → メモリ

################################################
🔥PHƯƠNG THỨC CHỈ ĐỊNH ĐỊA CHỈ Ô NHỚ

🔥 アドレッシング方式（Đánh địa chỉ）

👉 Cách CPU xác định địa chỉ toán hạng (operand)

1️⃣ 即値アドレッシング（Immediate）
🇯🇵

命令の中に値そのものが含まれている。
Giá trị ghi trực tiếp trong lệnh

📌 Ví dụ
MOV R1, #5


👉 dùng luôn 5

⏱ 計算量

Nhanh nhất

Không truy cập bộ nhớ

2️⃣ 直接アドレッシング（Direct）🔥

命令の中にオペランドのアドレスが書かれている。
Lệnh chứa địa chỉ thật của dữ liệu

📌 Ví dụ
MOV R1, [1000]


👉 lấy dữ liệu tại memory[1000]

3️⃣ 間接アドレッシング（Indirect）🔥🔥

命令が示すアドレスに，さらにアドレスが格納されている。

Lệnh trỏ tới địa chỉ chứa địa chỉ khác

📌 Ví dụ
MOV R1, [[1000]]

Bộ nhớ	Giá trị
M[1000]	2000
M[2000]	50

👉 kết quả = 50

4️⃣ レジスタアドレッシング（Register）

オペランドがレジスタにある。

Dữ liệu nằm trong thanh ghi

📌 Ví dụ
MOV R1, R2

5️⃣ レジスタ間接（Register Indirect）🔥

レジスタがメモリアドレスを保持する。
Thanh ghi chứa địa chỉ bộ nhớ

📌 Ví dụ
MOV R1, [R2]


👉 R2 = 1000 → lấy M[1000]

6️⃣ インデックスアドレッシング（Index）

基準アドレス + インデックス
Địa chỉ = base + index

📌 Ví dụ
MOV R1, [1000 + R3]


👉 dùng cho mảng

🔥 BẢNG TỔNG HỢP FE (RẤT QUAN TRỌNG)
方式	Nghĩa
即値	Giá trị
直接	Địa chỉ thật
間接	Địa chỉ của địa chỉ
レジスタ	Dữ liệu trong thanh ghi
レジスタ間接	Thanh ghi giữ địa chỉ
インデックス	base + offset
🎯 MẸO LÀM NHANH FE

Thấy # → 即値

Thấy [] → memory

Thấy [[ ]] → 間接

Thấy R → register

Thấy + → index


===============================================================
################################################################
🔥🔥🔥🔥CƠ CHẾ NGẮT🔥🔥🔥🔥🔥🔥🔥🔥

🔥 割込み（Interrupt）– Cơ chế ngắt
❓ Ngắt là gì?
🇯🇵

割込みとは，CPUが実行中の処理を一時中断し，
優先度の高い処理を先に実行する仕組み。

🇻🇳

Ngắt = CPU tạm dừng chương trình đang chạy
để xử lý sự kiện quan trọng hơn.

🔁 Quy trình xử lý ngắt (FE rất hay hỏi)
🇯🇵 CPUの割込み処理手順

現在の状態を保存（PC・レジスタ）

割込み要求を受理

割込み処理ルーチン（ISR）へジャンプ

ISR実行

状態を復元して元の処理に戻る

🇻🇳 Diễn giải ngắn

1️⃣ Lưu trạng thái
2️⃣ Nhận ngắt
3️⃣ Nhảy sang ISR
4️⃣ Xử lý
5️⃣ Quay lại chương trình cũ

🧠 Từ khóa bắt buộc nhớ (FE)
Thuật ngữ	Nghĩa
ISR	割込み処理ルーチン
割込みベクタ	Địa chỉ ISR
マスク	Chặn ngắt
優先度	Độ ưu tiên
🔥 Các loại ngắt (FE ưa hỏi)
1️⃣ 外部割込み（External）

Bàn phím, chuột, I/O

Do thiết bị ngoài

2️⃣ 内部割込み（Internal）

Chia cho 0

Tràn số

Lỗi lệnh

👉 còn gọi là 例外（Exception）

3️⃣ ソフトウェア割込み

Do chương trình gọi

Ví dụ: system call

===============================================================
################################################################
🔥🔥🔥🔥CƠ CHẾ NGẮT🔥🔥🔥🔥🔥🔥🔥🔥
  Phân loại theo cấu trúc hệ thống
システム構成による分類
1️⃣ 集中処理システム（Hệ thống xử lý tập trung）

Xử lý tập trung tại một máy chủ trung tâm

Terminal chỉ nhập/xuất dữ liệu

Ưu: quản lý dễ

Nhược: lỗi 1 điểm → toàn hệ thống dừng

2️⃣ 分散処理システム（Hệ thống xử lý phân tán）

Nhiều máy cùng xử lý, chia tải

Ưu: mở rộng tốt, độ tin cậy cao

Nhược: quản lý phức tạp

3️⃣ クライアント・サーバシステム（Client–Server）

Client yêu cầu, Server xử lý

Dạng phổ biến của phân tán

Ví dụ: Web, DB Server

4️⃣ デュアルシステム (Dual System) hoặc デュプレックスシステム (Duplex System)

 sử dụng hai máy chủ giống nhau hoạt động song song để đảm bảo tính sẵn sàng cao.
Nếu một máy gặp sự cố, máy còn lại sẽ tiếp tục hoạt động mà không làm gián đoạn dịch vụ.

Nhược: kiểm soát khó

⚠️ Có hai loại chính:
ホットスタンバイ (Hot Standby): Máy dự phòng luôn chạy song song và có thể tiếp quản ngay lập tức.

コールドスタンバイ (Cold Standby): Máy dự phòng không hoạt động cho đến khi máy chính gặp sự cố.


🔥🔥🔥🔥 Độ tin cậy và cách duy trì hoạt động của hệ thống🔥🔥🔥🔥
  🔹 フォールトトレランス（Fault Tolerance）

Hệ thống không dừng dù có lỗi

Tự động chuyển sang hệ thống dự phòng

🔹 フェールセーフ（Fail Safe）

Khi lỗi → chuyển sang trạng thái an toàn

Ưu tiên an toàn hơn tiếp tục hoạt động

🔹 フェールソフト（Fail Soft）

Khi lỗi → giảm chức năng, vẫn chạy được phần quan trọng
  
  🔹 Fool-proof（フールプルーフ）

Hệ thống được thiết kế để người dùng thao tác sai cũng không ảnh hưởng tới 
hoạt động

  
🔹 冗長化（Redundancy – Dự phòng）

Chuẩn bị nhiều thành phần giống nhau

Khi 1 cái lỗi → cái khác thay thế

Ví dụ:

二重化 (dual system)

多重化 (multiple)

  

冗長化: thêm đồ dự phòng

FT: lỗi vẫn chạy

FS: lỗi thì an toàn

FP: thao tác sai vẫn chạy
  
Fail soft: lỗi nhưng vẫn chạy một phần

🔥🔥🔥🔥RAID là gì?🔥🔥
  RAID (Redundant Array of Independent Disks)
→ Kỹ thuật ghép nhiều ổ cứng thành 1 hệ thống để:

✅ Tăng độ tin cậy (chống mất dữ liệu)

✅ Tăng tốc độ

Hoặc cả hai

Các mức RAID hay gặp (FE rất hay hỏi)
  
🔹 RAID 0 – Tăng tốc (KHÔNG an toàn)

Chia dữ liệu ra nhiều ổ (striping)(ストライピング)

Nhanh

❌ 1 ổ hỏng → mất hết dữ liệu

📌 Không có dự phòng

🔹 RAID 1 – An toàn

Sao chép y hệt dữ liệu sang ổ khác (mirroring)(ミラーリング)

1 ổ hỏng → vẫn chạy

❌ Tốn dung lượng (50%)

🔹 RAID 5 – Cân bằng (ra đề FE nhiều)
Chia đều dữ liệu và dùng mã parity để sửa lỗi
	Parity = dữ liệu kiểm tra dùng để phục hồi dữ liệu khi ổ đĩa bị hỏng.
Cần ≥ 3 ổ

Có parity (dữ liệu phục hồi)

chịu 1 ổ hỏng → vẫn hoạt động

📌 Phổ biến trong server

🔹 RAID 6

Giống RAID 5 nhưng có 2 parity

Chịu được 2 ổ hỏng

🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠🧠
Chỉ số tính năng của hệ thống
🔥 システム性能指標（Chỉ số hiệu năng hệ thống）
1️⃣ スループット（Throughput） ⭐⭐⭐

単位時間あたりに処理できる仕事量

Số lượng công việc xử lý trong 1 đơn vị thời gian

📌 Ví dụ
10件 / 秒

👉 FE rất thích hỏi cái này

2️⃣ 応答時間（Response Time） ⭐⭐⭐

要求してから結果が返るまでの時間

Thời gian từ lúc gửi yêu cầu đến lúc nhận kết quả

👉 Quan trọng cho hệ thống tương tác

3️⃣ ターンアラウンドタイム（Turnaround Time）

ジョブ投入から終了までの時間

Thời gian từ lúc đầu đến khi kết thúc công việc

4️⃣ 待ち時間（Waiting Time）

CPUを待っている時間

Thời gian chờ CPU

5️⃣ CPU利用率（CPU Utilization） ⭐⭐

CPUが仕事をしている割合

Tỷ lệ CPU đang bận

6️⃣ レイテンシ（Latency）

処理の遅延時間

Độ trễ

🔥 ベンチマークテスト（Benchmark Test）
🇯🇵

標準的なプログラムを実行して，
コンピュータの性能を測定する方法

Chạy chương trình chuẩn để
đo hiệu năng hệ thống

🎯 Mục đích

So sánh CPU

So sánh server

So sánh hệ thống

👉 FE hay hỏi: benchmark dùng để so sánh hiệu năng

🧠 Đo cái gì?
指標	      Nghĩa
処理時間	Thời gian xử lý
スループット	Lượng xử lý
応答時間	Response time
CPU使用率	CPU utilization

Kế hoạch dung lượng
🔥 キャパシティプランニング（Capacity Planning）
Scale-out: Thêm máy chủ để tăng hiệu năng tổng thể
Scale-up: Nâng cấp phần cứng máy chủ hiện có để tăng hiệu năng 

=============================================================
R-A-S-I-S（信頼性指標） chỉ số độ tin cậy
🔥 R-A-S-I-S 指標（Reliability, Availability, Serviceability, Integrity, Scalability）
1️⃣ R: Reliability（信頼性）
Hệ thống hoạt động đúng chức năng trong thời gian dài mà không bị lỗi
2️⃣ A: Availability（可用性）
Hệ thống luôn sẵn sàng để sử dụng khi cần thiết
3️⃣ S: Serviceability（保守性）
Dễ dàng bảo trì, sửa chữa và nâng cấp hệ thống
4️⃣ I: Integrity（完全性）
Dữ liệu và hệ thống không bị thay đổi hoặc hỏng hóc một cách trái phép
5️⃣ S: Security（安全性）
Hệ thống được bảo vệ khỏi các mối đe dọa và truy cập trái phép
=============================================================

MTBF (Mean Time Between Failures) : Thời gian trung bình giữa các lần hệ thống gặp sự cố.
→ MTBF càng lớn thì hệ thống càng đáng tin cậy.

Chỉ số thường gặp:
MTBF（平均故障間隔）: Thời gian trung bình giữa 2 lần lỗi
→ càng lớn càng tốt


MTBR（平均修復時間）: Thời gian sửa chữa trung bình
→ càng nhỏ càng tốt


2️⃣ 可用性（Availability – Khả năng sẵn sàng）

→ Xác suất hệ thống có thể sử dụng tại một thời điểm

Công thức FE hay ra:

可用性=  MTBF / (MTBF+MTTR)
	​

  ⚠️ Mẹo nhớ nhanh FE

信頼性: “có hay không lỗi”

可用性: “có dùng được không”


ĐỐI VỚI HỆ THỐNG NỐI TIẾP VÀ THỆ THỐNG SONG SONG
🔥 直列システムと並列システム（Hệ thống nối tiếp và song song）
1️⃣ 直列システム（Hệ thống nối tiếp）
👉 Tất cả thành phần phải hoạt động thì hệ thống mới hoạt động
可用性= A1 × A2 × A3 × ... × An
→ 可用性 giảm khi thêm thành phần
2️⃣ 並列システム（Hệ thống song song）
👉 Chỉ cần một thành phần hoạt động thì hệ thống vẫn hoạt động
可用性= 1 - (1 - A1) × (1 - A2) × (1 - A3) × ... × (1 - An)
→ 可用性 tăng khi thêm thành phần
➡️ KẾT LUẬN QUAN TRỌNG CHO FE
Hệ thống nối tiếp: thêm thành phần → 可用性 giảm
Hệ thống song song: thêm thành phần → 可用性 tăng


ĐỐI VỚI HỆ THỐNG ĐA KÊNH HÓA 
🔥 多重化システム（Hệ thống đa kênh hóa）
Hệ thống gồm nhiều thiết bị hoặc nhiều hệ thống con ghép nối tạo thành một hệ
thống lớn
👉 Mục đích: tăng độ tin cậy và hiệu năng
Vd hệ thống 1 nối tiếp, hệ thống 2 song song
-> tính từng hệ thống r nhân kết quả vs nhau

===============================================================
################################################################
🔥🔥🔥🔥HỆ ĐIỀU HÀNH🔥🔥🔥🔥🔥🔥🔥🔥
  Operating System (OS) – オペレーティングシステム
🔥 OSの役割（Vai trò của OS）
1️⃣ Quản lý job 
Job là những việc mà người dùng giao cho máy tính xử lý
 スプーリング (Spooling)： đưa dữ liệu vào một khu vực lưu trữ tạm thời trước khi đc xừ lý hoặc in ấn.
👉 Không cần chờ máy in xử lý mà có thể tiếp tục công việc khác

 バッファ(Buffer):là một khu vực bộ nhớ tạm thời dùng để lưu trữ dữ liệu đang chờ được xử lý hoặc truyền đi.
👉 Giúp điều hòa tốc độ giữa các thiết bị

2️⃣ Quản lý task マルチタスク ( đa nhiệm task )
Task là những mệnh lệnh mà hệ điều hành giao cho CPU thực hiện
singule task(シングルタスク): chỉ chạy 1 task tại 1 thời điểm
multitask(マルチタスク): chạy nhiều task cùng lúc

 2 phương pháp quản lý task
- ノンプリエンプティブ方式 (non-preemptive):KHÔNG CHIẾM QUYỀN... task chạy đến khi hoàn thành mới chuyển sang task khác
- プリエンプティブ方式 (preemptive):CHIẾM QUYỀN... hệ điều hành có thể tạm dừng task hiện tại để chuyển sang task khác

👉Quá trình 1 task từ lúc sinh ra tới khi hoàn tất
新規作成 → 実行待ち → 実行中 → 待機中 → 終了

        新規作成 (New)
             ↓
       実行待ち (Ready)
             ↓   ← CPU割当
        実行中 (Running)
          ↓        ↓
   I/O要求       時間切れ・高優先度割込み
    (I/O)             (Preempt)
      ↓                    ↓
  待機中 (Waiting)    実行待ち (Ready)
      ↓
  I/O完了
      ↓
 実行待ち (Ready)
      ↓
   実行中 (Running)
      ↓
   終了 (Exit)


   🔥🔥LÊN LỊCH THỰC THI TASK🔥🔥

  🧠 1. FCFS（先着順方式 – First Come First Serve）
  👉 Task đến trước được xử lý trước
  🧠 2. SJF（最短処理時間優先方式 – Shortest Job First）
  👉 Task có thời gian xử lý ngắn nhất được ưu tiên
  🧠 3.Priority Scheduling（優先度）
  👉 Task có độ ưu tiên cao được xử lý trước ➡️ Task đang chạy bị dừng (preempt) bị đẩy về Ready
  🧠 4. Round Robin（ラウンドロビン方式）
  👉 Mỗi task được cấp một khoảng thời gian (time slice)➡️ Mỗi task chạy tối đa q ms rồi nhường CPU

  🔥🔥QUẢN LÝ BỘ NHỚ ẢO 🔥🔥
  🧠 1. ページング方式 (Paging):Phương thức phân chia bộ nhớ thực và bộ nhớ ảo thành các trang với chiều dài cố định
  🧠 2. ページフォールト (Page Fault): cơ chế ngắt phát sinh Khi truy cập trang không có trong bộ nhớ chính.
  🧠 3. ページアウト (Page Out): chuyển trang từ bộ nhớ chính sang bộ nhớ phụ

 🔥 3 thuật toán thay thế trang
  🧠 1. FIFO (First In First Out): thay thế trang vào bộ nhớ lâu nhất
  🧠 2. LRU (Least Recently Used): thay thế trang lâu không sử dụng nhất
  🧠 3. LFU (Least Frequently Used): thay thế trang ít được sử dụng nhất

  🔥  スラッシング (Thrashing): Hiện tượng máy tính luôn phải chuyển đổi từ bộ nhớ thực sang bộ nhớ ảo

  ➡️ Giải pháp: tăng dung lượng bộ nhớ chính hoặc tối ưu hóa thuật toán thay thế trang.

  QUẢN LÝ DỮ LIỆU
🔥 ファイルシステム (File System)
Chức năng quản lý dữ liệu mà máy tính cần cho việc xử lý
1️⃣ ファイル管理 (Quản lý file)
👉 Tạo, xóa, đổi tên, di chuyển file
2️⃣ バックアップ (Sao lưu dữ liệu)
👉 Sao chép dữ liệu để phòng mất mát
3️⃣ アクセス制御 (Kiểm soát truy cập)
👉 Phân quyền đọc/ghi/xóa file cho người dùng
4️⃣ ディレクトリ管理 (Quản lý thư mục)
👉 Tổ chức file trong thư mục, cây thư mục

===============================================================
################################################################
🔥🔥🔥BACKUP🔥🔥🔥🔥🔥🔥🔥🔥
	1️⃣ フルバックアップ (Full Backup – Sao lưu toàn bộ)

📌 Là gì?
→ Sao lưu toàn bộ dữ liệu mỗi lần backup.

📌 Đặc điểm

Dữ liệu đầy đủ nhất
Dễ khôi phục
Tốn dung lượng & thời gian

📌 Ví dụ
Hôm nay backup → copy tất cả file A, B, C
👉 Nhớ nhanh: Full = copy hết

2️⃣ 差分バックアップ (Differential Backup – Sao lưu khác biệt)

📌 Là gì?
→ Chỉ sao lưu những thay đổi kể từ lần Full Backup gần nhất.

📌 Đặc điểm
Dung lượng tăng dần theo thời gian
Khôi phục cần:
1 Full + 1 Differential

📌 Ví dụ

Thứ 2: Full (A, B, C)
Thứ 3: đổi B → backup B
Thứ 4: đổi C → backup B + C
👉 Nhớ nhanh: Differential = so với Full

3️⃣ 増分バックアップ (Incremental Backup – Sao lưu tăng dần)

📌 Là gì?
→ Chỉ sao lưu những thay đổi so với lần backup gần nhất (bất kỳ loại nào).

📌 Đặc điểm
Nhẹ & nhanh nhất
Khôi phục cần:
1 Full + tất cả Incremental

📌 Ví dụ

Thứ 2: Full (A, B, C)
Thứ 3: đổi B → backup B
Thứ 4: đổi C → backup C

👉 Nhớ nhanh: Incremental = so với lần trước

===============================================================
################################################################
🔥🔥🔥CÁC CÔNG CỤ PHÁT TRIỂN🔥🔥🔥🔥🔥🔥🔥🔥	
	
🔥🔥ソースコード (Source Code)

📌 Là gì?
→ Code do con người viết, dễ đọc.

📌 Ví dụ

C, Java, JavaScript code

👉 Nhớ nhanh: Con người viết

🔥🔥オブジェクトコード (Object Code)

📌 Là gì?
→ Code đã được compiler dịch, máy tính hiểu.

📌 Đặc điểm

Dạng nhị phân

Con người khó đọc

👉 Nhớ nhanh: Máy tính hiểu

🔁 Quan hệ

ソースコード → (コンパイル) → オブジェクトコード


🔄 Trình tự compiler thực hiện
	（1）字句解析（Lexical Analysis）

📌 Làm gì?
→ Chia source code thành các phần nhỏ (token) và kiểm tra lỗi cơ bản.

👉 Nhớ nhanh: Cắt nhỏ – soi lỗi chữ

（2）構文解析（Syntax Analysis）

📌 Làm gì?
→ Kiểm tra cấu trúc / ngữ pháp của chương trình có đúng không.

👉 Nhớ nhanh: Đúng ngữ pháp chưa?

（3）意味解析（Semantic Analysis）

📌 Làm gì?
→ Kiểm tra ý nghĩa & logic có mâu thuẫn không
(ví dụ: dùng biến chưa khai báo, kiểu dữ liệu sai).

👉 Nhớ nhanh: Có hợp lý không?

（4）最適化（Optimization）

📌 Làm gì?
→ Cải thiện thứ tự tính toán, giảm tài nguyên, tăng tốc độ.

👉 Nhớ nhanh: Làm cho nhanh – gọn

（5）コード生成（Code Generation）

📌 Làm gì?
→ Tạo オブジェクトコード (mã máy).

👉 Nhớ nhanh: Tạo code cho máy

🧠 Cách nhớ 1 dòng (rất hay dùng khi thi FE)

Cắt → Kiểm → Hiểu → Tối ưu → Sinh mã

Hoặc theo tiếng Nhật:

字句 → 構文 → 意味 → 最適化 → コード生成
==========================================
🔥🔥リンカ（Linker）

📌 Là gì?
→ Nối nhiều object code lại thành 1 chương trình.

📌 Làm gì?
Ghép các file object
Giải quyết tham chiếu hàm/biến
👉 Nhớ nhanh: Link = nối

🔥🔥ロードモジュール（Load Module）

📌 Là gì?
→ Chương trình đã sẵn sàng để nạp vào bộ nhớ và chạy.

📌 Đặc điểm
Được tạo sau khi linker
Hệ điều hành dùng để load
👉 Nhớ nhanh: Load = nạp chạy

🔄 Luồng tổng quát (rất hay ra đề)

ソースコード
→ コンパイル
→ オブジェクトコード
→ リンカ
→ ロードモジュール
→ 実行

🧠 Mẹo nhớ thi FE
Compiler: dịch
Linker: nối
Loader: nạp
Run: Chạy
==========================================
	🔥🔥静的テスト và 動的テスト🔥🔥
	
	静的テスト（Static Test）
📌 Là gì?
→ Không chạy chương trình, chỉ xem / phân tích.

📌 Ví dụ
Review source code
Check thiết kế
Static analysis tool
👉 Nhớ nhanh: Không chạy

動的テスト（Dynamic Test）

📌 Là gì?
→ Chạy chương trình thật để kiểm tra.

📌 Ví dụ
Unit test
Integration test
System test

👉 Nhớ nhanh: Có chạy

	==========================================
	==========================================
	テストツールの種類（Phân loại test tool）
	
1️⃣静的テストツール（Static Test Tool）
👉 Không chạy chương trình, chỉ phân tích source code.
🔹 ソースコード解析ツール

📌 Làm gì?
→ Phân tích source code để phát hiện lỗi.

📌 Ví dụ lỗi
Viết sai quy tắc
Biến không dùng
Lỗi tiềm ẩn
👉 Nhớ: Soi lỗi trong code

🔹 プログラム構造解析ツール

📌 Làm gì?
→ Phân tích cấu trúc chương trình.

📌 Dùng để
Hiểu luồng xử lý
Gợi ý cải tiến code
👉 Nhớ: Xem cấu trúc

🔹 モジュールインタフェースチェックツール

📌 Làm gì?
→ Kiểm tra sự phù hợp giao diện giữa các module.

📌 Ví dụ
Kiểu tham số có khớp không
Số lượng tham số đúng chưa
👉 Nhớ: Check kết nối module

2️⃣ 動的テストツール（Dynamic Test Tool）

👉 Có chạy chương trình thật để test.

🔹 インスペクタ (Inspector)

📌 Làm gì?
→ Chạy chương trình và phát hiện lỗi khi chạy.

📌 Ví dụ
Lỗi runtime
Giá trị biến bất thường

👉 Nhớ: Chạy để bắt lỗi

🔹 テストカバレージツール (Test coverage)

📌 Làm gì?
→ Kiểm tra mức độ chương trình đã được test.

📌 Biết được
Dòng nào đã chạy
Nhánh nào chưa test
👉 Nhớ: Test đã phủ được bao nhiêu %

3️⃣テスト実施支援ツール（Test Support Tool）

👉 Hỗ trợ việc test, không trực tiếp tìm lỗi logic.

🔹 テストベッドツール

📌 Làm gì?
→ Tạo môi trường test tự động.

📌 Ví dụ
Tạo stub / driver
Giảm công làm tay
👉 Nhớ: Chuẩn bị môi trường test

🔹 テストデータ生成ツール

📌 Làm gì?
→ Tự động tạo dữ liệu test.

📌 Ví dụ
Dữ liệu lớn
Dữ liệu đặc biệt
👉 Nhớ: Sinh data test

🧠 Tổng hợp nhớ nhanh (rất hay ra FE)

静的 → không chạy → phân tích code

動的 → chạy thật → kiểm tra hành vi
==========================================
	==========================================
	PHÂN LOẠI PHẦN MỀM
	① ソフトウェアの形態（loại phần mềm）
🔹 オープンソースソフトウェア（OSS）

📌 Là gì?
→ Công khai source code, ai cũng có thể xem / sửa / phân phối theo license.

📌 Ví dụ
Eclipse
Linux

👉 Nhớ nhanh: Mở source

🔹 Eclipse

📌 Là gì?
→ IDE mã nguồn mở (OSS) để phát triển phần mềm.

📌 Đặc điểm
Miễn phí
Có thể mở rộng bằng plugin

👉 Nhớ nhanh: Eclipse = OSS IDE

🔹 商用ソフトウェア（Commercial Software）

📌 Là gì?
→ Phần mềm có bản quyền, phải trả phí.
📌 Đặc điểm
Không cho sửa source
Dùng theo điều kiện nhà cung cấp

📌 Ví dụ
Microsoft Office
Photoshop

👉 Nhớ nhanh: Trả tiền – đóng source

② Bản quyền & khái niệm liên quan
🔹 コピーライト（Copyright）

📌 Là gì?
→ Quyền tác giả mặc định khi tạo phần mềm.

📌 Đặc điểm
Không được tự do sao chép
Không được sửa / phân phối nếu chưa cho phép

👉 Nhớ nhanh: Có bản quyền

🔹 パブリックドメイン（Public Domain）

📌 Là gì?
→ Không có bản quyền.

📌 Đặc điểm
Ai dùng cũng được
Không cần xin phép

👉 Nhớ nhanh: Tự do hoàn toàn

🔹 パブリックドメインソフトウェア

📌 Là gì?
→ Phần mềm thuộc public domain.

👉 Nhớ nhanh: Free tuyệt đối

🔹 コピーレフト（Copyleft）

📌 Là gì?
→ Dùng copyright để bắt buộc chia sẻ tự do.

📌 Quy tắc quan trọng
Nếu sửa & phân phối → phải công khai source
Phải giữ cùng license

📌 Ví dụ license
GPL

👉 Nhớ nhanh: Chia sẻ ngược lại

🔹 コピーレフトのマーク

📌 Hình dạng
Ký hiệu © nhưng quay ngược

👉 Ý nghĩa

Phần mềm theo copyleft

==========================================
==========================================
🧠 Bộ nhớ bán dẫn là gì?

Bộ nhớ bán dẫn (半導体メモリ) là bộ nhớ:
bán dẫn là vật liệu nằm giữa chất dẫn điện và chất cách điện, thường là silicon.
Làm bằng chip điện tử
Truy cập rất nhanh
Dùng để lưu chương trình & dữ liệu khi máy chạy

📌 Ví dụ: RAM, ROM, Cache

🔥 Các loại bộ nhớ bán dẫn (hay ra FE)
1️⃣ RAM（主記憶装置 – Main Memory, Random Access Memory）CHỈ HOẠT ĐỘNG KHI CÓ ĐIỆN

👉 Bộ nhớ chính, CPU dùng trực tiếp

❌ Mất dữ liệu khi tắt máy (揮発性)
✔️ Rất nhanh
Các loại RAM:
  Loại	Ý nghĩa
  DRAM	Chậm hơn, dung lượng lớn
  SRAM	Rất nhanh, dùng làm Cache

2️⃣ ROM（Read Only Memory）CÓ THỂ LƯU DỮ LIỆU KHI TẮT MÁY

👉 Chỉ đọc, lưu chương trình khởi động
✔️ Không mất dữ liệu khi tắt máy
📌 Ví dụ: BIOS

3️⃣ Cache Memory（キャッシュメモリ）
👉 Nằm giữa CPU và RAM
✔️ Cực nhanh
❌ Dung lượng nhỏ
Là SRAM
📌 Giúp CPU đỡ phải đọc RAM nhiều

🧠 Thứ tự tốc độ (FE hay hỏi)
Cache > RAM > SSD > HDD

FLASH MEMORY (フラッシュメモリ)
👉 Bộ nhớ bán dẫn không bay hơi
✔️ Lưu dữ liệu khi tắt máy
✔️ Tốc độ nhanh hơn HDD/SSD
📌 Ví dụ: USB, thẻ nhớ, SSD


===============================================================
################################################################
🔥🔥🔥🔥MẠCH ĐIỆN ĐIỆN TỬ🔥🔥🔥🔥🔥🔥🔥🔥
   
  🧠 1. Memory Cell
👉 Là đơn vị nhỏ nhất lưu trữ dữ liệu trong bộ nhớ, chưa thông tin 0 hoặc 1, hay có thể nói bộ nhớ bán dẫn có vô số những memory cell
  🧠 2. Tụ điện (コンデンサ)
👉 Là thành phần lưu trữ điện tích, dùng để lưu trữ dữ liệu trong DRAM
  🧠3.Mạch Flip-Flop (フリップフロップ回路)
👉 Là mạch điện tử dùng để lưu trữ 1 bit dữ liệu, dùng lưu trạng thái dữ liệu ở cả quá khứ và hiện tại
  🧠(チャタリング)- Nhiễu
👉 Hiện tượng tiếp xúc không ổn định
  🧠(7セグメント表示器)
👉 Mạch hiển thị số thập phân 7 đoạn


🔥🔥🔥🔥Thiết kế giao diện người dùng🔥🔥🔥🔥🔥🔥🔥🔥
1️⃣ユーザビリティ（Usability – Khả năng sử dụng）
👉 Mức độ dễ dàng và hiệu quả mà người dùng có thể sử dụng giao diện.
 ユーザビリティの評価方法
方法	                      Nghĩa
インタビュー法	        Phỏng vấn người dùng
ヒューリスティック評価  Dựa theo đánh giá của các chuyên gia
ユーザビリティテスト   Quan sát người dùng thực hiện nhiệm vụ
ログデータ分析法      Phân tích dữ liệu sử dụng thực tế, ghi log lại hành vi người dùng

2️⃣入カチェック（Input Check – Kiểm tra đầu vào）
👉 Kiểm tra dữ liệu người dùng nhập vào để đảm bảo tính hợp lệ và an toàn
  ユーザビリティの評価方法
  論理チェック: Kiểm tra logic (ví dụ: ngày tháng hợp lệ)
  重複チェック: Kiểm tra trùng lặp (ví dụ: tên đăng nhập đã tồn tại)
  フォーマットチェック: Kiểm tra định dạng (ví dụ: email đúng định dạng)
  シーケンスチェック: Kiểm tra thứ tự (ví dụ: mã sản phẩm theo thứ tự tăng dần)
  範囲チェック: Kiểm tra phạm vi (ví dụ: tuổi từ 18 đến 65)

3️⃣ユーザビリティを向上させるその他の機能 （Các chức năng khác cải thiện khả năng sử dụng）
Undo機能: Cho phép người dùng hoàn tác thao tác gần nhất
マクロ機能: Tự động hóa chuỗi thao tác lặp đi lặp lại
ショートカットキー: Phím tắt giúp truy cập nhanh chức năng

 4.ユニバーサルデザイン（Universal Design – Thiết kế phổ quát）
👉 Thiết kế giao diện phù hợp với mọi người dùng, bao gồm cả người khuyết tật

5.バリアフリーデザイン: Thiết kế không rào cản (ví dụ: hỗ trợ người khiếm thị)

6.Webアクセシビリティ: Truy cập web dễ dàng cho mọi người

===============================================================
################################################################
🔥🔥🔥🔥CÔNG NGHỆ ĐA PHƯƠNG TIỆN🔥🔥🔥🔥🔥🔥🔥🔥
  🧠 1. 文字 (text)
  文字の表し方 (Biểu diễn ký tự)
ビットマップフォント: Dùng lưới điểm ảnh để biểu diễn ký tự
アウトラインフォント: Dùng các đường cong và hình học để biểu diễn ký tự

アウトラインフォント khi hiển thị ra màn hình cũng sẽ phải biên ra bitmap font để hiển thị được

  🧠 2. 画像 (image)
  画像の表し方 (Biểu diễn hình ảnh)
ビットマップ画像: Dùng lưới điểm ảnh để biểu diễn hình ảnh

  🧠 3. 音声 (audio)
  音声の表し方 (Biểu diễn âm thanh)
  PCMによるデータ変換: Chuyển đổi dữ liệu âm thanh thành dạng số bằng phương pháp PCM (Pulse Code Modulation)
  標本化: Lấy mẫu tín hiệu âm thanh liên tục thành các mẫu rời rạc
  量子化: Chuyển đổi các mẫu rời rạc thành các giá trị số
  符号化: Mã hóa các giá trị số thành dạng nhị phân 

  🧠 4.  静止画 (ảnh tĩnh)
  静止画の表し方 (Biểu diễn ảnh tĩnh)
ビットマップ画像: Dùng lưới điểm ảnh để biểu diễn hình ảnh

アンチエイリアシング: Kỹ thuật làm mịn cạnh răng cưa trong hình ảnh số

  🧠 5. 動画 (video)
  動画の表し方 (Biểu diễn video)
フレーム: Một hình ảnh tĩnh trong chuỗi hình ảnh tạo thành video
フレームレート: Số lượng khung hình hiển thị trên giây trong

H.264/MPEG-4 AVC: Chuẩn nén video phổ biến


  🧠 6. テクスチャマッピング (Texture Mapping, bản đồ bề mặt)
